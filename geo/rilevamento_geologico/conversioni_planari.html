<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bussola Geologica Interattiva</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
        }
        #compassCanvas {
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            background-color: #ffffff;
            border: 1px solid #e5e7eb;
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4">

    <div class="bg-white p-8 rounded-2xl shadow-xl w-full max-w-xl text-center">
        <h1 class="text-3xl font-bold text-gray-800 mb-6">Misure Geologiche Interattive</h1>
        
        <!-- LAYOUT CAMPI DI INPUT (2 righe) -->
        <div class="mb-8 w-full max-w-md mx-auto">
            
            <p class="text-sm font-semibold text-gray-500 mb-2">Metodo Strike / Dip</p>
            
            <!-- RIGA 1: Strike e Inclinazione -->
            <div class="grid grid-cols-2 gap-4 mb-4">
                
                <!-- Strike (Direzione del Piano) -->
                <div class="flex flex-col items-start">
                    <label for="strike" class="text-sm font-medium text-gray-700 mb-1">Strike (Piano) [°]</label>
                    <input type="text" id="strike" value="090" maxlength="3"
                           class="w-full p-2 border border-gray-300 rounded-lg text-center font-mono text-lg bg-yellow-50 focus:ring-yellow-500 focus:border-yellow-500 transition-colors">
                    <div id="strikeError" class="mt-1 text-sm text-red-600 h-5" style="visibility: hidden;">
                        Formato: 3 cifre (000-359)
                    </div>
                </div>

                <!-- Inclinazione (Dip Angle) - RIGA 1 -->
                <div class="flex flex-col items-start">
                    <label for="inclinazioneRiga1" class="text-sm font-medium text-gray-700 mb-1">Inclinazione (Angolo) [°]</label>
                    <input type="number" id="inclinazioneRiga1" value="45" min="0" max="90" step="1" 
                           class="w-full p-2 border border-gray-300 rounded-lg text-center font-mono text-lg focus:ring-blue-500 focus:border-blue-500 transition-colors">
                    <div class="mt-1 h-5"></div>
                </div>
            </div>

            <!-- Divisore -->
            <hr class="border-gray-300 my-4">

            <p class="text-sm font-semibold text-gray-500 mb-2">Metodo Dip Direction / Dip Angle</p>

            <!-- RIGA 2: Dip Direction e Inclinazione -->
            <div class="grid grid-cols-2 gap-4">
                
                <!-- Dip Direction (Direzione di Immersione) -->
                <div class="flex flex-col items-start">
                    <label for="dipDirezione" class="text-sm font-medium text-gray-700 mb-1">Dip Direction (Freccia) [°]</label>
                    <input type="text" id="dipDirezione" value="180" maxlength="3"
                           class="w-full p-2 border border-gray-300 rounded-lg text-center font-mono text-lg bg-red-50 focus:ring-red-500 focus:border-red-500 transition-colors">
                    <div id="dipDirezioneError" class="mt-1 text-sm text-red-600 h-5" style="visibility: hidden;">
                        Formato: 3 cifre (000-359)
                    </div>
                </div>

                <!-- Inclinazione (Dip Angle) - RIGA 2 (ORA EDITABILE) -->
                <div class="flex flex-col items-start">
                    <label for="inclinazioneRiga2" class="text-sm font-medium text-gray-700 mb-1">Inclinazione (Angolo) [°]</label>
                    <input type="number" id="inclinazioneRiga2" value="45" min="0" max="90" step="1" 
                           class="w-full p-2 border border-gray-300 rounded-lg text-center font-mono text-lg focus:ring-blue-500 focus:border-blue-500 transition-colors">
                    <div class="mt-1 h-5"></div>
                </div>
            </div>
        </div>

        <!-- Canvas per il disegno -->
        <canvas id="compassCanvas" width="450" height="450" class="rounded-full mx-auto"></canvas>

        <p class="mt-6 text-sm text-gray-600">
            La linea gialla è lo **Strike** e la freccia rossa è il **Dip Direction**. La loro relazione di $90^\circ$ viene gestita automaticamente.
        </p>
    </div>

    <script>
        // Funzione per convertire i gradi in radianti
        function toRadians(degrees) {
            return degrees * (Math.PI / 180);
        }
        
        // Funzione per disegnare una punta di freccia
        function drawArrowhead(ctx, x, y, angle, size) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);
            ctx.beginPath();
            ctx.moveTo(0, 0); // Punta della freccia
            ctx.lineTo(-size, size / 2);
            ctx.lineTo(-size, -size / 2);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }

        /**
         * Funzione di validazione generica per i campi direzione (3 cifre, 000-359).
         * @param {string} value - Il valore da validare.
         * @param {string} errorId - L'ID del div di errore.
         * @param {boolean} updateUI - Se mostrare o nascondere il messaggio di errore.
         * @returns {boolean} True se valido.
         */
        function validateDirection(value, errorId, updateUI = true) {
            const errorDiv = document.getElementById(errorId);
            const regex = /^\d{3}$/; 
            const numValue = parseInt(value, 10);
            const isValid = regex.test(value) && numValue >= 0 && numValue <= 359;

            if (updateUI) {
                if (isValid) {
                    errorDiv.style.visibility = 'hidden';
                    errorDiv.textContent = '';
                } else {
                    errorDiv.style.visibility = 'visible';
                    errorDiv.textContent = 'Formato: 3 cifre (000-359)';
                }
            }

            return isValid;
        }

        /**
         * Logica per aggiornare il Dip Direction quando lo Strike cambia.
         * @param {number} strikeValue - Valore dello Strike in gradi (0-359).
         */
        function updateDipDirection(strikeValue) {
            // Dip Direction = Strike + 90 gradi (convenzione della mano destra)
            let dipDirection = (strikeValue + 90) % 360;
            
            // Aggiorna il campo Dip Direction formattandolo a 3 cifre con zeri iniziali
            const dipDirezioneInput = document.getElementById('dipDirezione');
            dipDirezioneInput.value = dipDirection.toString().padStart(3, '0');
            
            drawCompass();
        }

        /**
         * Logica per aggiornare lo Strike quando il Dip Direction cambia.
         * @param {number} dipDirectionValue - Valore del Dip Direction in gradi (0-359).
         */
        function updateStrike(dipDirectionValue) {
            // Strike = Dip Direction - 90 gradi. Aggiungiamo 360 per gestire i valori negativi.
            let strike = (dipDirectionValue - 90 + 360) % 360;
            
            // Aggiorna il campo Strike formattandolo a 3 cifre con zeri iniziali
            const strikeInput = document.getElementById('strike');
            strikeInput.value = strike.toString().padStart(3, '0');

            drawCompass();
        }
        
        /**
         * Sincronizza il valore di Inclinazione tra i due campi e ridisegna.
         * @param {string} sourceId - ID del campo che ha innescato la modifica.
         */
        function syncInclinazione(sourceId) {
            const incl1 = document.getElementById('inclinazioneRiga1');
            const incl2 = document.getElementById('inclinazioneRiga2');
            
            let value = (sourceId === 'inclinazioneRiga1') ? incl1.value : incl2.value;
            
            // Sincronizza l'altro campo
            if (sourceId === 'inclinazioneRiga1') {
                incl2.value = value;
            } else {
                incl1.value = value;
            }

            drawCompass();
        }


        function drawCompass() {
            const canvas = document.getElementById('compassCanvas');
            if (!canvas.getContext) return;
            const ctx = canvas.getContext('2d');

            // --- LETTURA E VALIDAZIONE DEI VALORI ---
            const strikeInput = document.getElementById('strike');
            const dipDirezioneInput = document.getElementById('dipDirezione');
            // Leggiamo il valore di Inclinazione dal primo campo (è sincronizzato)
            const inclinazioneInput = document.getElementById('inclinazioneRiga1'); 

            // Valori numerici (usiamo 0 se l'input non è valido)
            let strike = 0;
            if (validateDirection(strikeInput.value, 'strikeError', false)) {
                 strike = parseInt(strikeInput.value, 10);
            }
            
            let dipDirection = 0;
            if (validateDirection(dipDirezioneInput.value, 'dipDirezioneError', false)) {
                 dipDirection = parseInt(dipDirezioneInput.value, 10);
            }

            const inclinazione = parseFloat(inclinazioneInput.value) || 0;

            // Impostazioni del canvas
            const width = canvas.width;
            const height = canvas.height;
            const center = { x: width / 2, y: height / 2 };
            const radius = (width / 2) * 0.75; 
            const textClearance = (width / 2) * 0.05;
            const maxTextRadius = (width / 2) - textClearance; 
            
            const diameter = radius * 2;
            const lineLength = diameter * 0.60; 
            const distanceToCenter = lineLength / 2;
            const arrowHeadSize = 10; 

            // Pulisce il canvas
            ctx.clearRect(0, 0, width, height);

            // --- 1. Disegna la circonferenza principale ---
            ctx.beginPath();
            ctx.arc(center.x, center.y, radius, 0, 2 * Math.PI);
            ctx.strokeStyle = '#4b5563'; 
            ctx.lineWidth = 3;
            ctx.stroke();
            ctx.closePath();

            // --- 2. Definisce e disegna le tacche e le etichette (Punti Cardinali) ---
            const markers = [
                { degree: 0, textLabel: 'N', color: '#ef4444', length: 15, size: '22px' },
                { degree: 90, textLabel: 'E', color: '#2563eb', length: 15, size: '22px' },
                { degree: 180, textLabel: 'S', color: '#22c55e', length: 15, size: '22px' },
                { degree: 270, textLabel: 'W', color: '#f59e0b', length: 15, size: '22px' },
                { degree: 45, textLabel: '45°', color: '#9ca3af', length: 8, size: '18px' },
                { degree: 135, textLabel: '135°', color: '#9ca3af', length: 8, size: '18px' },
                { degree: 225, textLabel: '225°', color: '#9ca3af', length: 8, size: '18px' },
                { degree: 315, textLabel: '315°', color: '#9ca3af', length: 8, size: '18px' },
            ];

            markers.forEach(marker => {
                const adjustedDegrees = marker.degree - 90; 
                const angleRad = toRadians(adjustedDegrees);
                
                const startX = center.x + radius * Math.cos(angleRad);
                const startY = center.y + radius * Math.sin(angleRad);
                const endRadius = radius - marker.length;
                const endX = center.x + endRadius * Math.cos(angleRad);
                const endY = center.y + endRadius * Math.sin(angleRad);

                // Disegna la linea della tacca
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.strokeStyle = marker.color;
                ctx.lineWidth = marker.length > 10 ? 3 : 2; 
                ctx.stroke();
                ctx.closePath();

                // Disegna l'etichetta 
                if (marker.textLabel) {
                    const desiredRadius = radius + 30; 
                    const textRadius = Math.min(desiredRadius, maxTextRadius);

                    const textX = center.x + textRadius * Math.cos(angleRad);
                    const textY = center.y + textRadius * Math.sin(angleRad);

                    ctx.fillStyle = marker.color;
                    ctx.font = `${marker.size} Inter`;
                    ctx.textAlign = 'center'; 
                    ctx.textBaseline = 'middle'; 
                    
                    ctx.fillText(marker.textLabel, textX, textY);
                }
            });

            // --- 3. Disegna STRIKE e DIP DIRECTION ---
            // Usiamo la validazione di Dip Direction perché è il valore che determina la freccia
            if (validateDirection(dipDirezioneInput.value, 'dipDirezioneError', false)) {
                
                // --- A. Strike (Linea Gialla) ---
                // Angolo Strike in radianti
                const strikeAngleRad = toRadians(strike - 90); 
                
                // Punto 1: Inizio della linea Strike (opposto)
                const end1X = center.x + (-distanceToCenter) * Math.cos(strikeAngleRad);
                const end1Y = center.y + (-distanceToCenter) * Math.sin(strikeAngleRad);
                
                // Punto 2: Fine della linea Strike (verso lo Strike)
                const end2X = center.x + distanceToCenter * Math.cos(strikeAngleRad);
                const end2Y = center.y + distanceToCenter * Math.sin(strikeAngleRad);

                // Disegna il segmento Strike (Giallo)
                ctx.beginPath();
                ctx.moveTo(end1X, end1Y); 
                ctx.lineTo(end2X, end2Y); 
                ctx.strokeStyle = '#f59e0b'; // Giallo/Arancio
                ctx.lineWidth = 4;
                ctx.stroke();
                ctx.closePath();
                
                // Disegna il cerchietto grigio chiaro sulla punta Strike (end2)
                ctx.beginPath();
                ctx.arc(end2X, end2Y, 5, 0, 2 * Math.PI); 
                ctx.fillStyle = '#9ca3af'; 
                ctx.fill();
                ctx.closePath();
                
                // --- B. Dip Direction (Freccia Rossa) ---
                // Angolo Dip Direction in radianti
                const dipAngleRad = toRadians(dipDirection - 90); 
                
                // Calcoliamo le coordinate del punto Dip Direction (punta della freccia)
                const dipDirectionX = center.x + distanceToCenter * Math.cos(dipAngleRad);
                const dipDirectionY = center.y + distanceToCenter * Math.sin(dipAngleRad);

                // B1. Disegna la freccia dal centro al Dip Direction
                ctx.beginPath();
                ctx.moveTo(center.x, center.y); 
                ctx.lineTo(dipDirectionX, dipDirectionY); 
                ctx.strokeStyle = '#ef4444'; // Rosso vivo per la freccia
                ctx.lineWidth = 3;
                ctx.stroke();
                ctx.closePath();
                
                // B2. Disegna la punta della freccia (Dip Direction Marker)
                ctx.fillStyle = '#ef4444';
                drawArrowhead(ctx, dipDirectionX, dipDirectionY, dipAngleRad, arrowHeadSize); 
                
                // --- C. Aggiunge l'angolo di Inclinazione (Dip Angle) accanto alla freccia Dip Direction ---
                // Calcola la posizione del testo appena fuori dal cerchio
                const textDipRadius = distanceToCenter + 20; 
                const textX = center.x + textDipRadius * Math.cos(dipAngleRad);
                const textY = center.y + textDipRadius * Math.sin(dipAngleRad);

                // Disegna il testo dell'inclinazione
                ctx.fillStyle = '#1e40af'; // Blu scuro
                ctx.font = '16px Inter';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(`${inclinazione}°`, textX, textY);
            }
        }

        // --- GESTIONE DEGLI INPUT ---
        function setupEventListeners() {
            const strikeInput = document.getElementById('strike');
            const dipDirezioneInput = document.getElementById('dipDirezione');
            const inclinazioneInput1 = document.getElementById('inclinazioneRiga1');
            const inclinazioneInput2 = document.getElementById('inclinazioneRiga2');

            // Funzione helper per gestire l'input e la validazione/aggiornamento della Direzione
            const handleDirectionInput = (inputElement, errorId, updateFunction) => {
                const listener = function() {
                    let value = this.value.replace(/\D/g, ''); 
                    this.value = value.substring(0, 3); 
                    
                    if (validateDirection(this.value, errorId, true)) {
                        updateFunction(parseInt(this.value, 10));
                    }
                };

                inputElement.addEventListener('input', listener);
                inputElement.addEventListener('change', listener);
            };

            // 1. Modifica dello Strike -> Aggiorna Dip Direction
            handleDirectionInput(strikeInput, 'strikeError', updateDipDirection);

            // 2. Modifica del Dip Direction -> Aggiorna Strike
            handleDirectionInput(dipDirezioneInput, 'dipDirezioneError', updateStrike);

            // 3. Modifica dell'Inclinazione (Dip Angle) - Sincronizzazione e ridisegno
            inclinazioneInput1.addEventListener('input', () => syncInclinazione('inclinazioneRiga1'));
            inclinazioneInput1.addEventListener('change', () => syncInclinazione('inclinazioneRiga1'));

            inclinazioneInput2.addEventListener('input', () => syncInclinazione('inclinazioneRiga2'));
            inclinazioneInput2.addEventListener('change', () => syncInclinazione('inclinazioneRiga2'));
        }

        // Avvia il disegno e configura gli eventi
        window.onload = function() {
            // Inizializzazione per coerenza
            document.getElementById('strike').value = '090'; 
            updateDipDirection(90); // Imposta Dip Direction a 180 inizialmente
            setupEventListeners();
        };
    </script>

</body>
</html>

