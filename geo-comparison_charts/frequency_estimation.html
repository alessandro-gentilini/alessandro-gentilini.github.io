<html>
    <head>
        <title>beta - Interactive comparison charts for estimating percentage of particles</title>
	<script>
        // https://rosettacode.org/wiki/Sutherland-Hodgman_polygon_clipping#JavaScript
        function clip (subjectPolygon, clipPolygon) {
 
            var cp1, cp2, s, e;
            var inside = function (p) {
                return (cp2[0]-cp1[0])*(p[1]-cp1[1]) > (cp2[1]-cp1[1])*(p[0]-cp1[0]);
            };
            var intersection = function () {
                var dc = [ cp1[0] - cp2[0], cp1[1] - cp2[1] ],
                    dp = [ s[0] - e[0], s[1] - e[1] ],
                    n1 = cp1[0] * cp2[1] - cp1[1] * cp2[0],
                    n2 = s[0] * e[1] - s[1] * e[0], 
                    n3 = 1.0 / (dc[0] * dp[1] - dc[1] * dp[0]);
                return [(n1*dp[0] - n2*dc[0]) * n3, (n1*dp[1] - n2*dc[1]) * n3];
            };
            var outputList = subjectPolygon;
            cp1 = clipPolygon[clipPolygon.length-1];
            for (j in clipPolygon) {
                var cp2 = clipPolygon[j];
                var inputList = outputList;
                outputList = [];
                s = inputList[inputList.length - 1]; //last on the input list
                for (i in inputList) {
                    var e = inputList[i];
                    if (inside(e)) {
                        if (!inside(s)) {
                            outputList.push(intersection());
                        }
                        outputList.push(e);
                    }
                    else if (inside(s)) {
                        outputList.push(intersection());
                    }
                    s = e;
                }
                cp1 = cp2;
            }
            return outputList
        }
 
        function drawPolygon(context, polygon, strokeStyle, fillStyle) {
            context.strokeStyle = strokeStyle;
            context.fillStyle = fillStyle;
            context.beginPath();
            context.moveTo(polygon[0][0],polygon[0][1]); //first vertex
            for (var i = 1; i < polygon.length ; i++)
                context.lineTo(polygon[i][0],polygon[i][1]);
            context.lineTo(polygon[0][0],polygon[0][1]); //back to start
            context.fill();
            context.stroke();
            context.closePath();
        }

        function translate(rect,t){
            var a = [rect[0][0]+t[0],rect[0][1]+t[1]]
            var b = [rect[1][0]+t[0],rect[1][1]+t[1]]
            var c = [rect[2][0]+t[0],rect[2][1]+t[1]]
            var d = [rect[3][0]+t[0],rect[3][1]+t[1]]
            return [a,b,c,d]
        }

        function rotate(p,theta) {
            return [p[0]*Math.cos(theta)-p[1]*Math.sin(theta),p[0]*Math.sin(theta)+p[1]*Math.cos(theta)]
        }

        function rotate_r(rect,theta){
            var a = rotate(rect[0],theta)
            var b = rotate(rect[1],theta)
            var c = rotate(rect[2],theta)
            var d = rotate(rect[3],theta)
            return [a,b,c,d]
        }

        function rect(b,h){
            return [[0,0],[b,0],[b,h],[0,h]]
        }

        // Algorithm P in section 3.4.1 of Knuth's TAOCP (volume 2).
        function gaussian(mean, stddev) {
            return function() {
                if(stddev<=0) throw new Error("stddev must be > 0")
                var V1
                var V2
                var S
                do{
                    var U1 = Math.random()
                    var U2 = Math.random()
                    V1 = 2*U1-1
                    V2 = 2*U2-1
                    S = V1*V1+V2*V2
                }while(S >= 1)
                if(S===0) return 0
                return mean+stddev*(V1*Math.sqrt(-2*Math.log(S)/S))
            }
        }        

        function distance(p1,p2)
        {
            return Math.sqrt(Math.pow(p1[0]-p2[0],2)+Math.pow(p1[1]-p2[1],2))
        }

        function is_outside(rect,circle_center,circle_radius)
        {
            return distance(rect[0],circle_center)>circle_radius &&
            distance(rect[1],circle_center)>circle_radius &&
            distance(rect[2],circle_center)>circle_radius &&
            distance(rect[3],circle_center)>circle_radius 
        }

        function determinant(p1,p2){
            var x1 = p1[0]
            var y1 = p1[1]
            var x2 = p2[0]
            var y2 = p2[1]
            return x1*y2-x2*y1
        }

        // http://mathworld.wolfram.com/PolygonArea.html
        function polygon_area(p){
            var A = 0
            var sz = p.length
            for(var i = 0; i < sz; i++){
                A += determinant(p[i],p[(i+1)%sz])
            }
            return Math.abs(A/2)
        }

        function main(freq,mean_H,stddev_H,mean_W,stddev_W,mean_theta,stddev_theta)
        {
	        var context = document.getElementById('canvas').getContext('2d');
           
            var base_dist = gaussian(mean_W,stddev_W)
            var height_dist = gaussian(mean_H,stddev_H)
            var rotation_dist = gaussian(mean_theta,stddev_theta)
            var limit_x = 700
            var limit_y = 700
            var radius = 300
            var circle_center = [limit_x/2, limit_y/2]

            var approx_circle = []
            var N = 50
            for(var i = 0; i < N; i++ ){
                var theta = i/N*2*Math.PI
                var x = circle_center[0]+radius*Math.cos(theta)
                var y = circle_center[0]+radius*Math.sin(theta)
                approx_circle.push([x,y])
            }

            drawPolygon(context,approx_circle,'#888','#fff')
            var approx_circle_area = polygon_area(approx_circle)

            var rr = []
            var particle_area = 0
            do{
                r = translate(rotate_r(rect(base_dist(),height_dist()),rotation_dist()),[limit_x*Math.random(),limit_y*Math.random()])
                if(is_outside(r,circle_center,radius)) continue
                var overlap = false
                for(var i = 0; i < rr.length; i++){
                    var clipped = clip(r,rr[i])
                    if(clipped.length){
                        overlap = true
                    }
                }
                if(!overlap){
                    var clipped = clip(r,approx_circle)
                    if(clipped.length){
                        drawPolygon(context,clipped,'#888','#fff')
                        particle_area += polygon_area(clipped)
                        rr.push(r)
                    }
                }
            }while(100*particle_area/approx_circle_area<freq)
            
            context.font = (radius/10).toFixed(0)+"px Arial";
            var W = limit_x
            var H = (limit_y-2*radius)/2
            context.clearRect(0,0,W,H)
            context.fillText((100*particle_area/approx_circle_area).toFixed(0)+"%",circle_center[0],circle_center[1]-1.01*radius)
        }

        function frequency_oninput()
        {
            var freq = parseFloat(document.getElementById("frequency").value)
            var mean_H = parseFloat(document.getElementById("mean_H").value)
            var mean_W = parseFloat(document.getElementById("mean_W").value)
            var stddev_H = parseFloat(document.getElementById("stddev_H").value)            
            var stddev_W = parseFloat(document.getElementById("stddev_W").value)
            var mean_theta = parseFloat(document.getElementById("mean_theta").value)*Math.PI/180
            var stddev_theta = parseFloat(document.getElementById("stddev_theta").value)*Math.PI/180    
            if(freq<=0||freq>50) return
            if(freq > 40){
                document.getElementById("text").innerHTML="Warning: it may be slow!"
            } else {
                document.getElementById("text").innerHTML=""
            }
            main(freq,mean_H,stddev_H,mean_W,stddev_W,mean_theta,stddev_theta)
        }
        </script>
    <body onload="main(5,10,.5,100,5,0,2*Math.PI/180)">
        <h1>Interactive comparison charts for estimating percentage of particles</h1>
        <p>
        <label for="frequency">Frequency in %:</label>
        <input type="number" id="frequency" oninput="frequency_oninput()" value="5">
        </p>
        <p>
        <label for="mean_H">Average particle height in px:</label>
        <input type="number" id="mean_H" oninput="frequency_oninput()" value="10">    
        <label for="stddev_H">Standard deviation for particle height in px:</label>
        <input type="number" id="stddev_H" oninput="frequency_oninput()" value=".5">        
        </p>
        <p>
        <label for="mean_W">Average particle width in px:</label>
        <input type="number" id="mean_W" oninput="frequency_oninput()" value="100">    
        <label for="stddev_W">Standard deviation for particle height in px:</label>
        <input type="number" id="stddev_W" oninput="frequency_oninput()" value="5">        
        </p>
        <p>
        <label for="mean_theta">Average angle in degree:</label>
        <input type="number" id="mean_theta" oninput="frequency_oninput()" value="0">    
        <label for="stddev_theta">Standard deviation for angle in degree:</label>
        <input type="number" id="stddev_theta" oninput="frequency_oninput()" value="2">        
        </p>             
        <div id="text"></div>
        <canvas id='canvas' width='700' height='700' style="border:1px solid #000000;"></canvas>
    </body>
</html>