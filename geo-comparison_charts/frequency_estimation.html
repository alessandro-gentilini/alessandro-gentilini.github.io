<html>
    <head>
	<script>
        // https://rosettacode.org/wiki/Sutherland-Hodgman_polygon_clipping#JavaScript
        function clip (subjectPolygon, clipPolygon) {
 
            var cp1, cp2, s, e;
            var inside = function (p) {
                return (cp2[0]-cp1[0])*(p[1]-cp1[1]) > (cp2[1]-cp1[1])*(p[0]-cp1[0]);
            };
            var intersection = function () {
                var dc = [ cp1[0] - cp2[0], cp1[1] - cp2[1] ],
                    dp = [ s[0] - e[0], s[1] - e[1] ],
                    n1 = cp1[0] * cp2[1] - cp1[1] * cp2[0],
                    n2 = s[0] * e[1] - s[1] * e[0], 
                    n3 = 1.0 / (dc[0] * dp[1] - dc[1] * dp[0]);
                return [(n1*dp[0] - n2*dc[0]) * n3, (n1*dp[1] - n2*dc[1]) * n3];
            };
            var outputList = subjectPolygon;
            cp1 = clipPolygon[clipPolygon.length-1];
            for (j in clipPolygon) {
                var cp2 = clipPolygon[j];
                var inputList = outputList;
                outputList = [];
                s = inputList[inputList.length - 1]; //last on the input list
                for (i in inputList) {
                    var e = inputList[i];
                    if (inside(e)) {
                        if (!inside(s)) {
                            outputList.push(intersection());
                        }
                        outputList.push(e);
                    }
                    else if (inside(s)) {
                        outputList.push(intersection());
                    }
                    s = e;
                }
                cp1 = cp2;
            }
            return outputList
        }
 
        function drawPolygon(context, polygon, strokeStyle, fillStyle) {
            context.strokeStyle = strokeStyle;
            context.fillStyle = fillStyle;
            context.beginPath();
            context.moveTo(polygon[0][0],polygon[0][1]); //first vertex
            for (var i = 1; i < polygon.length ; i++)
                context.lineTo(polygon[i][0],polygon[i][1]);
            context.lineTo(polygon[0][0],polygon[0][1]); //back to start
            context.fill();
            context.stroke();
            context.closePath();
        }

        function translate(rect,t){
            var a = [rect[0][0]+t[0],rect[0][1]+t[1]]
            var b = [rect[1][0]+t[0],rect[1][1]+t[1]]
            var c = [rect[2][0]+t[0],rect[2][1]+t[1]]
            var d = [rect[3][0]+t[0],rect[3][1]+t[1]]
            return [a,b,c,d]
        }

        function rotate(p,theta) {
            return [p[0]*Math.cos(theta)-p[1]*Math.sin(theta),p[0]*Math.sin(theta)+p[1]*Math.cos(theta)]
        }

        function rotate_r(rect,theta){
            var a = rotate(rect[0],theta)
            var b = rotate(rect[1],theta)
            var c = rotate(rect[2],theta)
            var d = rotate(rect[3],theta)
            return [a,b,c,d]
        }

        function rect(b,h){
            return [[0,0],[b,0],[b,h],[0,h]]
        }

        // https://stackoverflow.com/a/35599181
        // returns a gaussian random function with the given mean and stdev.
        function gaussian(mean, stdev) {
            var y2;
            var use_last = false;
            return function() {
                var y1;
                if(use_last) {
                y1 = y2;
                use_last = false;
                }
                else {
                    var x1, x2, w;
                    do {
                        x1 = 2.0 * Math.random() - 1.0;
                        x2 = 2.0 * Math.random() - 1.0;
                        w  = x1 * x1 + x2 * x2;               
                    } while( w >= 1.0);
                    w = Math.sqrt((-2.0 * Math.log(w))/w);
                    y1 = x1 * w;
                    y2 = x2 * w;
                    use_last = true;
            }

            var retval = mean + stdev * y1;
            if(retval > 0) 
                return retval;
            return -retval;
        }
        }        
 
        window.onload = function () {
	        var context = document.getElementById('canvas').getContext('2d');
	        var subjectPolygon = [[0, 0], [20, 0], [20, 20], [0, 20]]
	        var clipPolygon = [[100, 100], [300, 100], [300, 300], [100, 300]]
	        var clippedPolygon = clip(subjectPolygon, clipPolygon);
	        drawPolygon(context, clipPolygon, '#888','#88f');
            drawPolygon(context, rect(100,10), '#888','#88f');
            drawPolygon(context, rect(10,100), '#888','#88f');
	        //drawPolygon(context, subjectPolygon, '#888','#8f8');
            //drawPolygon(context, translate(subjectPolygon,[20,20]), '#888','#8f8');
            //drawPolygon(context, translate(rotate_r(subjectPolygon,Math.PI/4),[40,40]), '#888','#8f8');
            if(clippedPolygon.length){
                drawPolygon(context, clippedPolygon, '#000','#0ff');
            }
            var standard = gaussian(0, 1);
            alert(standard())
    	}
        </script>
    <body>
    	<canvas id='canvas' width='400' height='400'></canvas>
    </body>
</html>